<div id="audio-player-{{ .Ordinal }}" class="audio-player" role="region" aria-label="Audio conversation player (table)" data-ordinal="{{ .Ordinal }}">
  <div class="controls" aria-label="Playback controls">
    <div class="left-controls">
      <button id="prev-button-{{ .Ordinal }}" class="icon-button" aria-label="Previous line" title="Previous line (←)" disabled>
        <span class="icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" width="18" height="18" focusable="false"><path fill="currentColor" d="M6 6h2v12H6V6zm11.5 6L9 18V6l8.5 6z"/></svg>
        </span>
        <span class="btn-label">Previous</span>
      </button>
      <button id="play-button-{{ .Ordinal }}" class="icon-button primary" aria-label="Play the conversation" title="Play/Pause (Space)" data-state="play" disabled>
        <span class="icon icon-play" aria-hidden="true">
          <svg viewBox="0 0 24 24" width="18" height="18" focusable="false"><path fill="currentColor" d="M8 5v14l11-7z"/></svg>
        </span>
        <span class="icon icon-pause" aria-hidden="true">
          <svg viewBox="0 0 24 24" width="18" height="18" focusable="false"><path fill="currentColor" d="M6 5h4v14H6zm8 0h4v14h-4z"/></svg>
        </span>
        <span class="btn-label">Play</span>
      </button>
      <button id="next-button-{{ .Ordinal }}" class="icon-button" aria-label="Next line" title="Next line (→)" disabled>
        <span class="icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" width="18" height="18" focusable="false"><path fill="currentColor" d="M16 6h2v12h-2V6zM6.5 12L15 18V6l-8.5 6z"/></svg>
        </span>
        <span class="btn-label">Next</span>
      </button>
    </div>
    <div class="right-controls">
      <label class="speed-label" for="speed-control-{{ .Ordinal }}">Speed</label>
      <select id="speed-control-{{ .Ordinal }}" aria-label="Playback speed" title="Playback speed">
        <option value="0.5">0.5x</option>
        <option value="0.75">0.75x</option>
        <option value="1.0" selected>1.0x</option>
        <option value="1.25">1.25x</option>
        <option value="1.5">1.5x</option>
        <option value="2.0">2.0x</option>
      </select>
    </div>
  </div>

  <div class="progress-row" aria-label="Playback progress">
    <span id="elapsed-{{ .Ordinal }}" class="time" aria-live="off">0:00</span>
    <input id="progress-{{ .Ordinal }}" class="progress" type="range" min="0" max="100" value="0" step="0.1" aria-label="Seek current line" disabled />
    <span id="duration-{{ .Ordinal }}" class="time" aria-live="off">0:00</span>
    <span id="index-{{ .Ordinal }}" class="index" aria-live="polite" aria-atomic="true">—</span>
  </div>

  <div id="loading-{{ .Ordinal }}" class="loading" aria-live="polite">Loading audio…</div>
  <div id="status-{{ .Ordinal }}" class="sr-only" aria-live="polite" aria-atomic="true"></div>

  <div class="transcript-table-container">
    <table id="transcript-table-{{ .Ordinal }}" class="transcript-table" aria-label="Conversation transcript table">
      <colgroup>
        <col class="col-speaker" />
        <col class="col-text" />
        <col class="col-meaning" />
      </colgroup>
      <thead>
        <tr>
          <th scope="col">{{ with .Get "headerSpeaker" }}{{ . }}{{ else }}Speaker{{ end }}</th>
          <th scope="col">{{ with .Get "headerText" }}{{ . }}{{ else }}Text{{ end }}</th>
          <th scope="col">{{ with .Get "headerMeaning" }}{{ . }}{{ else }}Meaning{{ end }}</th>
        </tr>
      </thead>
      <tbody id="transcript-body-{{ .Ordinal }}"></tbody>
    </table>
  </div>
</div>

<script>
(function() {
  // Constants and DOM elements
  const container = document.getElementById('audio-player-{{ .Ordinal }}');
  const ordinal = Number((container && container.dataset && container.dataset.ordinal) || '0');
  const playButton = document.getElementById(`play-button-${ordinal}`);
  const prevButton = document.getElementById(`prev-button-${ordinal}`);
  const nextButton = document.getElementById(`next-button-${ordinal}`);
  const speedControl = document.getElementById(`speed-control-${ordinal}`);
  const tableBody = document.getElementById(`transcript-body-${ordinal}`);
  const loadingDiv = document.getElementById(`loading-${ordinal}`);
      const progress = document.getElementById(`progress-${ordinal}`);
      const elapsedLabel = document.getElementById(`elapsed-${ordinal}`);
      const durationLabel = document.getElementById(`duration-${ordinal}`);
      const indexLabel = document.getElementById(`index-${ordinal}`);
      const statusLive = document.getElementById(`status-${ordinal}`);

  const scriptJson = '{{ .Get "json" }}';
  const audioPath = '{{ .Get "audiopath" }}';
  const pauseDuration = 1000; // milliseconds
  const meaningFieldParam = '{{ with .Get "meaningField" }}{{ . }}{{ end }}'.trim();

  // Playback state
  let preloadedAudios = [];
  let currentAudio = null;
  let currentIndex = -1;
  let state = 'stopped'; // 'stopped', 'playing', 'paused'
  let playbackSpeed = 1.0;
  let timeoutId = null;
  let hasFocus = false;
  // Track whether the last initiated playback was a single line (not the full sequence)
  let lastSingleClip = false;

  // Utilities
  const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
  const formatTime = (t) => {
    if (!isFinite(t) || t < 0) return '0:00';
    const m = Math.floor(t / 60);
    const s = Math.floor(t % 60);
    return `${m}:${s.toString().padStart(2, '0')}`;
  };
  const setPlayVisual = (mode /* 'play' | 'pause' | 'resume' */) => {
    const label = playButton.querySelector('.btn-label');
    if (mode === 'pause') {
      playButton.setAttribute('data-state', 'pause');
      label && (label.textContent = 'Pause');
      playButton.setAttribute('aria-label', 'Pause the conversation');
  playButton.setAttribute('aria-pressed', 'true');
    } else if (mode === 'resume') {
      playButton.setAttribute('data-state', 'play');
      label && (label.textContent = 'Resume');
      playButton.setAttribute('aria-label', 'Resume the conversation');
  playButton.setAttribute('aria-pressed', 'false');
    } else {
      playButton.setAttribute('data-state', 'play');
      label && (label.textContent = 'Play');
      playButton.setAttribute('aria-label', 'Play the conversation');
  playButton.setAttribute('aria-pressed', 'false');
    }
  };

  // Helpers
  const getMeaning = (item) => {
    if (meaningFieldParam && item && (meaningFieldParam in item)) {
      return item[meaningFieldParam] ?? '';
    }
    // sensible fallbacks
    return item.meaning ?? item.translation ?? item.en ?? '';
  };

  const enableControls = () => {
  [playButton, prevButton, nextButton].forEach(btn => {
      btn.disabled = false;
      btn.setAttribute('aria-disabled', 'false');
    });
  };

  const disableControls = () => {
  [playButton, prevButton, nextButton].forEach(btn => {
      btn.disabled = true;
      btn.setAttribute('aria-disabled', 'true');
    });
  };

  // Speed control handler
  speedControl.addEventListener('change', () => {
    playbackSpeed = parseFloat(speedControl.value);
    if (currentAudio) currentAudio.playbackRate = playbackSpeed;
  });

  // Load and initialize audio
  loadingDiv.style.display = 'block';
  fetch(scriptJson)
    .then(response => response.json())
    .then(scriptArray => {
      // Determine whether a Meaning column is needed based on data
      const hasMeaning = scriptArray.some(item => {
        const val = (function getMeaningProbe(it) {
          if (meaningFieldParam && it && (meaningFieldParam in it)) return it[meaningFieldParam];
          return it?.meaning ?? it?.translation ?? it?.en ?? '';
        })(item);
        return typeof val === 'string' ? val.trim().length > 0 : Boolean(val);
      });

      // Adjust thead/colgroup for dynamic columns
      const tableEl = document.getElementById(`transcript-table-${ordinal}`);
      const colgroupEl = tableEl && tableEl.querySelector('colgroup');
      const theadRowEl = tableEl && tableEl.querySelector('thead tr');
      if (!hasMeaning && colgroupEl && theadRowEl) {
        // Remove meaning column definition
        const meaningCol = colgroupEl.querySelector('.col-meaning');
        if (meaningCol) meaningCol.remove();
        // Remove meaning header cell (3rd th)
        const ths = theadRowEl.querySelectorAll('th');
        if (ths && ths[2]) ths[2].remove();
      }

      // Preload audio files
      const preloadPromises = scriptArray.map(item => new Promise((resolve, reject) => {
        const audio = new Audio(audioPath + item.audio);
        audio.preload = 'auto';
        let ready = false;
        const cleanup = () => {
          audio.removeEventListener('canplaythrough', onReady);
          audio.removeEventListener('error', onError);
        };
        const onReady = () => { ready = true; cleanup(); resolve(audio); };
        const onError = () => { cleanup(); reject(new Error(`Failed to load ${item.audio}`)); };
        audio.addEventListener('canplaythrough', onReady, { once: true });
        audio.addEventListener('error', onError, { once: true });
        // Fallback in case canplaythrough never fires
        setTimeout(() => { if (!ready) resolve(audio); }, 4000);
      }));

      Promise.all(preloadPromises)
        .then(audios => {
          preloadedAudios = audios;
          loadingDiv.style.display = 'none';
          enableControls();

          // Build transcript table
          scriptArray.forEach((item, index) => {
            const tr = document.createElement('tr');
            tr.classList.add('transcript-row');
            tr.dataset.index = index;
            tr.setAttribute('tabindex', '0');
            tr.setAttribute('role', 'button');
            const labelText = item.type === 'dialogue'
              ? `${item.speaker}: ${item.text}`
              : `Effect: ${item.name}`;
            tr.setAttribute('aria-label', `Play line ${index + 1}: ${labelText}`);

            // Speaker
            const tdSpeaker = document.createElement('td');
            tdSpeaker.textContent = item.type === 'dialogue' ? (item.speaker ?? '') : '';

            // Text
            const tdText = document.createElement('td');
            if (item.type === 'dialogue') {
              tdText.textContent = item.text ?? '';
            } else if (item.type === 'effect') {
              const i = document.createElement('i');
              i.textContent = `Effect: ${item.name}`;
              tdText.appendChild(i);
            }

            tr.appendChild(tdSpeaker);
            tr.appendChild(tdText);

            // Meaning (optional)
            if (hasMeaning) {
              const tdMeaning = document.createElement('td');
              tdMeaning.textContent = getMeaning(item) || '';
              tr.appendChild(tdMeaning);
            }

            tr.addEventListener('click', () => playSingleClip(index));
            tr.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') playSingleClip(index); });

            tableBody.appendChild(tr);
          });

          // Playback functions
          function updateIndexLabel() {
            if (currentIndex >= 0) {
              indexLabel.textContent = `${currentIndex + 1} / ${scriptArray.length}`;
            } else {
              indexLabel.textContent = '—';
            }
          }

          function attachAudioHandlers(audio) {
            if (!audio) return;
            audio.playbackRate = playbackSpeed;
            // Duration labels
            const computeDuration = () => {
              let d = NaN;
              if (isFinite(audio.duration) && audio.duration > 0) {
                d = audio.duration;
              } else if (audio.seekable && audio.seekable.length) {
                d = Number(audio.seekable.end(0)) || NaN;
              }
              durationLabel.textContent = formatTime(d);
              progress.setAttribute('aria-valuetext', `0:00 of ${formatTime(d)}`);
            };
            computeDuration();
            progress.disabled = false;
            progress.value = 0;
            progress.style.setProperty('--pct', '0%');
            elapsedLabel.textContent = '0:00';
            updateIndexLabel();
            audio.ontimeupdate = () => {
              if (!isFinite(audio.duration) || audio.duration <= 0) return;
              const pct = (audio.currentTime / audio.duration) * 100;
              const clamped = clamp(pct, 0, 100);
              progress.value = clamped;
              progress.style.setProperty('--pct', `${clamped}%`);
              const elapsed = formatTime(audio.currentTime);
              elapsedLabel.textContent = elapsed;
              progress.setAttribute('aria-valuetext', `${elapsed} of ${formatTime(audio.duration)}`);
            };
            audio.onloadedmetadata = computeDuration;
          }

          function detachAudioHandlers(audio) {
            if (!audio) return;
            audio.ontimeupdate = null;
          }

          function playSingleClip(index) {
            if (timeoutId) clearTimeout(timeoutId);
            if (currentAudio) { currentAudio.pause(); detachAudioHandlers(currentAudio); }
            currentIndex = Math.max(0, Math.min(index, scriptArray.length - 1));
            currentAudio = preloadedAudios[currentIndex];
            currentAudio.currentTime = 0; // Reset to start
            currentAudio.playbackRate = playbackSpeed;
            highlightRow(currentIndex);
            currentAudio.play();
            state = 'playing';
            lastSingleClip = true; // mark mode
            setPlayVisual('pause');
            statusLive.textContent = `Playing line ${currentIndex + 1} of ${scriptArray.length}`;
            attachAudioHandlers(currentAudio);
            currentAudio.onended = () => {
              // Keep highlight so user sees reference point
              state = 'stopped';
              setPlayVisual('play');
              statusLive.textContent = `Finished line ${currentIndex + 1}. Press Play to continue with the conversation.`;
            };
          }

          function playSequence() {
            if (state === 'paused') {
              currentAudio.play();
              state = 'playing';
              setPlayVisual('pause');
              statusLive.textContent = `Resumed line ${currentIndex + 1} of ${scriptArray.length}`;
            } else {
              if (currentAudio) { currentAudio.pause(); detachAudioHandlers(currentAudio); }
              currentIndex = currentIndex < 0 ? 0 : currentIndex;
              playNext();
            }
            state = 'playing';
          }

          function pausePlayback() {
            if (currentAudio) currentAudio.pause();
            if (timeoutId) clearTimeout(timeoutId);
            state = 'paused';
            setPlayVisual('resume');
            statusLive.textContent = 'Paused';
          }

          function playNext() {
            if (currentIndex >= scriptArray.length) {
              state = 'stopped';
              setPlayVisual('play');
              removeHighlight();
              return;
            }
            if (currentAudio) { currentAudio.pause(); detachAudioHandlers(currentAudio); }
            currentAudio = preloadedAudios[currentIndex];
            currentAudio.currentTime = 0;
            currentAudio.playbackRate = playbackSpeed;
            highlightRow(currentIndex);
            currentAudio.play();
            statusLive.textContent = `Playing line ${currentIndex + 1} of ${scriptArray.length}`;
            attachAudioHandlers(currentAudio);
            currentAudio.onended = () => {
              if (state === 'playing' && currentIndex < scriptArray.length - 1) {
                timeoutId = setTimeout(() => {
                  currentIndex++;
                  playNext();
                }, pauseDuration);
              } else {
                state = 'stopped';
                setPlayVisual('play');
                removeHighlight();
              }
            };
          }

          // Skip controls
          prevButton.addEventListener('click', () => {
            if (currentIndex > 0) {
              currentIndex--;
              if (state === 'playing') {
                if (timeoutId) clearTimeout(timeoutId);
                playNext();
              } else {
                playSingleClip(currentIndex);
              }
            }
          });

          nextButton.addEventListener('click', () => {
            if (currentIndex < scriptArray.length - 1) {
              currentIndex++;
              if (state === 'playing') {
                if (timeoutId) clearTimeout(timeoutId);
                playNext();
              } else {
                playSingleClip(currentIndex);
              }
            } else if (currentIndex < 0) {
              playSingleClip(0); // Start from first if no current index
            }
          });

          // Play/Pause toggle
          playButton.addEventListener('click', () => {
            if (state === 'playing') {
              pausePlayback();
            } else {
              // If we just finished (or are stopped after) a single clip, advance to the next line for sequence playback
              if (lastSingleClip && state !== 'paused') {
                // Only advance if not already at final line
                if (currentIndex < scriptArray.length - 1) {
                  currentIndex = currentIndex + 1; // start sequence from the following line
                } else {
                  // If user was on last line, restart sequence from beginning
                  currentIndex = 0;
                  statusLive.textContent = 'Restarting from the beginning.';
                }
                lastSingleClip = false; // reset flag
              }
              playSequence();
            }
          });

          // Progress/seek
          progress.addEventListener('input', () => {
            if (!currentAudio || !isFinite(currentAudio.duration) || currentAudio.duration <= 0) return;
            const pct = parseFloat(progress.value) / 100;
            currentAudio.currentTime = clamp(currentAudio.duration * pct, 0, currentAudio.duration - 0.01);
            elapsedLabel.textContent = formatTime(currentAudio.currentTime);
            progress.style.setProperty('--pct', `${clamp(parseFloat(progress.value), 0, 100)}%`);
          });

          // Keyboard shortcuts scoped to this player (focus or hover within container)
          container.addEventListener('focusin', () => { hasFocus = true; });
          container.addEventListener('focusout', () => {
            setTimeout(() => { hasFocus = container.contains(document.activeElement); }, 0);
          });
          container.addEventListener('mouseenter', () => { hasFocus = true; });
          container.addEventListener('mouseleave', () => { hasFocus = container.contains(document.activeElement); });
          document.addEventListener('keydown', (e) => {
            if (!hasFocus) return;
            const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
            if (tag === 'input' || tag === 'select' || tag === 'textarea' || tag === 'button') return;
            if (e.key === ' ') {
              e.preventDefault();
              if (state === 'playing') pausePlayback(); else playSequence();
            } else if (e.key === 'ArrowLeft') {
              e.preventDefault();
              prevButton.click();
            } else if (e.key === 'ArrowRight') {
              e.preventDefault();
              nextButton.click();
            }
          });

          // Highlighting helpers
          function highlightRow(index) {
            tableBody.querySelectorAll('.transcript-row').forEach(el => {
              el.classList.remove('playing');
              el.removeAttribute('aria-current');
            });
            const row = tableBody.querySelector(`[data-index="${index}"]`);
            if (row) {
              row.classList.add('playing');
              row.setAttribute('aria-current', 'true');
              // keep row visible
              row.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            }
          }

          function removeHighlight() {
            tableBody.querySelectorAll('.transcript-row').forEach(el => {
              el.classList.remove('playing');
              el.removeAttribute('aria-current');
            });
          }
        })
        .catch(error => {
          console.error('Error preloading audio:', error);
          loadingDiv.textContent = 'Failed to load audio';
          loadingDiv.setAttribute('aria-live', 'assertive');
          disableControls();
        });
    })
    .catch(error => {
      console.error('Error loading JSON:', error);
      loadingDiv.textContent = 'Failed to load script';
      disableControls();
    });
})();
</script>

<style>
/* Container */
.audio-player { padding: 10px; }

/* Controls */
.controls { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 8px; flex-wrap: wrap; }
.left-controls, .right-controls { display: flex; align-items: center; gap: 8px; }
.speed-label { font-size: 12px; opacity: 0.8; }

.icon-button { display: inline-flex; align-items: center; gap: 8px; border-radius: 8px; background-color: #f2f4f8; color: #0a2a6b; border: 1px solid #d5d9e2; padding: 8px 12px; cursor: pointer; transition: background-color 0.2s, border-color 0.2s, transform 0.02s; font-size: 14px; }
.icon-button .icon { line-height: 0; display: inline-flex; }
.icon-button.primary { background-color: #0a37a7; border-color: #0a37a7; color: #fff; }
.icon-button:hover { background-color: #e8ebf1; }
.icon-button.primary:hover { background-color: #082d8a; }
.icon-button:active { transform: translateY(1px); }
.icon-button[disabled], .icon-button[aria-disabled="true"] { opacity: 0.6; cursor: not-allowed; }
.icon-button .btn-label { user-select: none; }
@media (max-width: 520px) { .icon-button .btn-label { display: none; } }

/* Toggle play/pause icons via data-state */
button[data-state="play"] .icon-pause { display: none; }
button[data-state="pause"] .icon-play { display: none; }

/* Progress row */
.progress-row { display: grid; grid-template-columns: auto 1fr auto auto; gap: 8px; align-items: center; margin: 6px 0 10px; }
.time { font-variant-numeric: tabular-nums; font-size: 12px; color: #444; }
.index { font-size: 12px; color: #444; justify-self: end; min-width: 64px; text-align: right; }
.progress { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; border-radius: 999px; background: linear-gradient(90deg, #0a37a7 var(--pct, 0%), #e0e6ef var(--pct, 0%)); outline: none; }
.progress:disabled { opacity: 0.6; cursor: not-allowed; }
.progress::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; background: #0a37a7; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 0 1px #0a37a7; cursor: pointer; }
.progress::-moz-range-thumb { width: 14px; height: 14px; background: #0a37a7; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 0 1px #0a37a7; cursor: pointer; }

/* Select (speed) */
select { background-color: #0a37a7; color: white; border: none; border-radius: 6px; padding: 6px 8px; cursor: pointer; font-size: 14px; }
select:hover { background-color: #082d8a; }
select option { background-color: white; color: black; }

/* Loading */
.loading { display: none; font-style: italic; color: #666; margin: 10px 0; position: relative; }
.loading::before { content: ""; width: 14px; height: 14px; border: 2px solid #d0d6e0; border-top-color: #0a37a7; border-radius: 50%; display: inline-block; margin-right: 8px; vertical-align: -2px; animation: spin 0.9s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }

/* Screen reader only */
.sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 1px, 1px); white-space: nowrap; border: 0; }

/* Transcript table */
.transcript-table-container { overflow-x: auto; overflow-y: auto; border: 3px dashed #e0e0e0; border-radius: 5px; -webkit-overflow-scrolling: touch; overscroll-behavior: contain; }
.transcript-table { width: 100%; max-width: 100%; border-collapse: collapse; table-layout: fixed; }
.transcript-table col.col-speaker { width: 10ch; }
.transcript-table col.col-text { width: auto; }
.transcript-table col.col-meaning { width: 28ch; }
.transcript-table th, .transcript-table td { border-bottom: 1px solid #eee; padding: 6px 8px; text-align: left; white-space: normal; overflow-wrap: break-word; word-break: normal; hyphens: auto; }
.transcript-row { cursor: pointer; }
.transcript-table tr.transcript-row td { transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out; }
.audio-player .transcript-table tr.transcript-row td:first-child { border-left: 4px solid transparent; }
.audio-player .transcript-table tr.transcript-row.playing td { background-color: #eaf3ff !important; }
.audio-player .transcript-table tr.transcript-row.playing td:first-child { border-left: 4px solid #0a37a7; }
.audio-player .transcript-table tr.transcript-row:focus { outline: 2px solid #0a37a7; outline-offset: -2px; }

/* Mobile optimizations */
@media (max-width: 520px) {
  /* Give browser freedom to size columns better */
  .transcript-table { table-layout: auto; min-width: 640px; }
  /* Tighten speaker column to free space for text */
  .transcript-table col.col-speaker { width: 6ch; }
  /* Slightly reduce cell padding on small screens */
  .transcript-table th, .transcript-table td { padding: 6px; }
}

/* Dark mode adjustments */
@media (prefers-color-scheme: dark) {
  .audio-player .transcript-table tr.transcript-row.playing td { background-color: #1f2b46 !important; color: #f5f7ff !important; }
  .audio-player .transcript-table tr.transcript-row.playing td:first-child { border-left-color: #6ea0ff; }
  .audio-player .transcript-table tr.transcript-row.playing td strong,
  .audio-player .transcript-table tr.transcript-row.playing td em,
  .audio-player .transcript-table tr.transcript-row.playing td i,
  .audio-player .transcript-table tr.transcript-row.playing td a { color: inherit !important; }
  .audio-player .transcript-table tr.transcript-row.playing td a { text-decoration: underline; }
  .audio-player .transcript-table tr.transcript-row:focus { outline-color: #6ea0ff; }
  .icon-button { background-color: #1e293b; color: #dbe5ff; border-color: #293548; }
  .icon-button:hover { background-color: #243043; }
  .progress { background: linear-gradient(90deg, #6ea0ff var(--pct, 0%), #2b3a55 var(--pct, 0%)); }
  .progress::-webkit-slider-thumb, .progress::-moz-range-thumb { background: #6ea0ff; box-shadow: 0 0 0 1px #6ea0ff; }
  .time, .index { color: #c9d4f0; }
}

/* Respect theme toggle via Bootstrap's data-bs-theme="dark" */
[data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td { background-color: #1f2b46 !important; color: #f5f7ff !important; }
[data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td:first-child { border-left-color: #6ea0ff; }
[data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td strong,
[data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td em,
[data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td i,
[data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td a { color: inherit !important; }
[data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td a { text-decoration: underline; }
[data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row:focus { outline-color: #6ea0ff; }
[data-bs-theme="dark"] .icon-button { background-color: #1e293b; color: #dbe5ff; border-color: #293548; }
[data-bs-theme="dark"] .icon-button:hover { background-color: #243043; }
[data-bs-theme="dark"] .progress { background: linear-gradient(90deg, #6ea0ff var(--pct, 0%), #2b3a55 var(--pct, 0%)); }
[data-bs-theme="dark"] .progress::-webkit-slider-thumb, [data-bs-theme="dark"] .progress::-moz-range-thumb { background: #6ea0ff; box-shadow: 0 0 0 1px #6ea0ff; }
[data-bs-theme="dark"] .time, [data-bs-theme="dark"] .index { color: #c9d4f0; }

</style>
