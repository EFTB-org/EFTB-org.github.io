<div id="audio-player-{{ .Ordinal }}" class="audio-player" role="region" aria-label="Audio conversation player (table)"
  data-ordinal="{{ .Ordinal }}">
  <div class="controls" aria-label="Playback controls">
    <div class="left-controls">
      <button id="prev-button-{{ .Ordinal }}" class="icon-button" aria-label="Previous line" title="Previous line (←)"
        disabled>
        <span class="icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" width="18" height="18" focusable="false">
            <path fill="currentColor" d="M6 6h2v12H6V6zm11.5 6L9 18V6l8.5 6z" />
          </svg>
        </span>
        <span class="btn-label">Previous</span>
      </button>
      <button id="play-button-{{ .Ordinal }}" class="icon-button primary" aria-label="Play the conversation"
        title="Play/Pause (Space)" data-state="play" disabled>
        <span class="icon icon-play" aria-hidden="true">
          <svg viewBox="0 0 24 24" width="18" height="18" focusable="false">
            <path fill="currentColor" d="M8 5v14l11-7z" />
          </svg>
        </span>
        <span class="icon icon-pause" aria-hidden="true">
          <svg viewBox="0 0 24 24" width="18" height="18" focusable="false">
            <path fill="currentColor" d="M6 5h4v14H6zm8 0h4v14h-4z" />
          </svg>
        </span>
        <span class="btn-label">Play</span>
      </button>
      <button id="next-button-{{ .Ordinal }}" class="icon-button" aria-label="Next line" title="Next line (→)" disabled>
        <span class="icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" width="18" height="18" focusable="false">
            <path fill="currentColor" d="M16 6h2v12h-2V6zM6.5 12L15 18V6l-8.5 6z" />
          </svg>
        </span>
        <span class="btn-label">Next</span>
      </button>
      <div class="sfx-control">
        <input type="checkbox" id="sfx-toggle-{{ .Ordinal }}" class="sfx-checkbox" checked
          aria-label="Toggle sound effects">
        <label for="sfx-toggle-{{ .Ordinal }}" class="sfx-label" title="Sound Effects">SFX</label>
      </div>
      <div class="bt-control">
        <input type="checkbox" id="bt-toggle-{{ .Ordinal }}" class="bt-checkbox"
          aria-label="Toggle Bluetooth Keep-Alive">
        <label for="bt-toggle-{{ .Ordinal }}" class="bt-label"
          title="Bluetooth Keep-Alive (prevents audio cutoff)">BT</label>
      </div>
    </div>
    <div class="right-controls">
      <label class="speed-label" for="speed-control-{{ .Ordinal }}">Speed</label>
      <select id="speed-control-{{ .Ordinal }}" aria-label="Playback speed" title="Playback speed">
        <option value="0.5">0.5x</option>
        <option value="0.75">0.75x</option>
        <option value="1.0" selected>1.0x</option>
        <option value="1.25">1.25x</option>
        <option value="1.5">1.5x</option>
        <option value="2.0">2.0x</option>
      </select>
    </div>
  </div>

  <div class="progress-row" aria-label="Playback progress">
    <span id="elapsed-{{ .Ordinal }}" class="time" aria-live="off">0:00</span>
    <input id="progress-{{ .Ordinal }}" class="progress" type="range" min="0" max="100" value="0" step="0.1"
      aria-label="Seek current line" disabled />
    <span id="duration-{{ .Ordinal }}" class="time" aria-live="off">0:00</span>
    <span id="index-{{ .Ordinal }}" class="index" aria-live="polite" aria-atomic="true">—</span>
  </div>

  <div id="loading-{{ .Ordinal }}" class="loading" aria-live="polite">Loading audio…</div>
  <div id="status-{{ .Ordinal }}" class="sr-only" aria-live="polite" aria-atomic="true"></div>

  <div class="transcript-table-container">
    <table id="transcript-table-{{ .Ordinal }}" class="transcript-table" aria-label="Conversation transcript table">
      <colgroup>
        <col class="col-speaker" />
        <col class="col-text" />
        <col class="col-meaning" />
      </colgroup>
      <thead>
        <tr>
          <th scope="col">{{ with .Get "headerSpeaker" }}{{ . }}{{ else }}Speaker{{ end }}</th>
          <th scope="col">{{ with .Get "headerText" }}{{ . }}{{ else }}Text{{ end }}</th>
          <th scope="col">{{ with .Get "headerMeaning" }}{{ . }}{{ else }}Meaning{{ end }}</th>
        </tr>
      </thead>
      <tbody id="transcript-body-{{ .Ordinal }}"></tbody>
    </table>
  </div>
</div>

<script>
  (function () {
    // Constants and DOM elements
    const container = document.getElementById('audio-player-{{ .Ordinal }}');
    const ordinal = Number((container && container.dataset && container.dataset.ordinal) || '0');
    const playButton = document.getElementById(`play-button-${ordinal}`);
    const prevButton = document.getElementById(`prev-button-${ordinal}`);
    const nextButton = document.getElementById(`next-button-${ordinal}`);
    const speedControl = document.getElementById(`speed-control-${ordinal}`);
    const tableBody = document.getElementById(`transcript-body-${ordinal}`);
    const loadingDiv = document.getElementById(`loading-${ordinal}`);
    const progress = document.getElementById(`progress-${ordinal}`);
    const elapsedLabel = document.getElementById(`elapsed-${ordinal}`);
    const durationLabel = document.getElementById(`duration-${ordinal}`);
    const indexLabel = document.getElementById(`index-${ordinal}`);
    const statusLive = document.getElementById(`status-${ordinal}`);
    const sfxToggle = document.getElementById(`sfx-toggle-${ordinal}`);

    const scriptJson = '{{ .Get "json" }}';
    const audioPath = '{{ .Get "audiopath" }}';
    const pauseDuration = 1000; // milliseconds
    const meaningFieldParam = '{{ with .Get "meaningField" }}{{ . }}{{ end }}'.trim();

    // Playback state
    let preloadedAudios = [];
    let currentAudio = null;
    let currentIndex = -1;
    let state = 'stopped'; // 'stopped', 'playing', 'paused'
    let playbackSpeed = 1.0;
    let timeoutId = null;
    let hasFocus = false;
    // Track whether the last initiated playback was a single line (not the full sequence)
    let lastSingleClip = false;

    // Sound Effects
    const sfxInsert = new Audio('/audio/effects/cassette_insert.mp3');
    const sfxEject = new Audio('/audio/effects/cassette_eject.mp3');
    let sfxEnabled = true;

    function tryPlaySfx(audio) {
      if (!sfxEnabled) return Promise.resolve();
      audio.currentTime = 0;
      return new Promise(resolve => {
        const onEnded = () => {
          audio.removeEventListener('ended', onEnded);
          audio.removeEventListener('error', onEnded);
          resolve();
        };
        audio.addEventListener('ended', onEnded);
        audio.addEventListener('error', onEnded);
        audio.play().catch(e => {
          console.warn('SFX play failed', e);
          onEnded();
        });
      });
    }

    if (sfxToggle) {
      sfxToggle.addEventListener('change', () => {
        sfxEnabled = sfxToggle.checked;
      });
    }

    // Bluetooth Toggle
    const btToggle = document.getElementById(`bt-toggle-${ordinal}`);
    if (btToggle && window.AudioUtils) {
      // Set initial state
      btToggle.checked = window.AudioUtils.getBluetoothMode();

      // Handle user change
      btToggle.addEventListener('change', () => {
        window.AudioUtils.setBluetoothMode(btToggle.checked);
      });

      // Listen for global changes (sync other players)
      window.addEventListener('audio-bluetooth-change', (e) => {
        btToggle.checked = e.detail.enabled;
      });
    }

    // Utilities
    const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
    const formatTime = (t) => {
      if (!isFinite(t) || t < 0) return '0:00';
      const m = Math.floor(t / 60);
      const s = Math.floor(t % 60);
      return `${m}:${s.toString().padStart(2, '0')}`;
    };
    const setPlayVisual = (mode /* 'play' | 'pause' | 'resume' */) => {
      const label = playButton.querySelector('.btn-label');
      if (mode === 'pause') {
        playButton.setAttribute('data-state', 'pause');
        label && (label.textContent = 'Pause');
        playButton.setAttribute('aria-label', 'Pause the conversation');
        playButton.setAttribute('aria-pressed', 'true');
      } else if (mode === 'resume') {
        playButton.setAttribute('data-state', 'play');
        label && (label.textContent = 'Resume');
        playButton.setAttribute('aria-label', 'Resume the conversation');
        playButton.setAttribute('aria-pressed', 'false');
      } else {
        playButton.setAttribute('data-state', 'play');
        label && (label.textContent = 'Play');
        playButton.setAttribute('aria-label', 'Play the conversation');
        playButton.setAttribute('aria-pressed', 'false');
      }
    };

    // Helpers
    const getMeaning = (item) => {
      if (meaningFieldParam && item && (meaningFieldParam in item)) {
        return item[meaningFieldParam] ?? '';
      }
      // sensible fallbacks
      return item.meaning ?? item.translation ?? item.en ?? '';
    };

    const enableControls = () => {
      [playButton, prevButton, nextButton].forEach(btn => {
        btn.disabled = false;
        btn.setAttribute('aria-disabled', 'false');
      });
    };

    const disableControls = () => {
      [playButton, prevButton, nextButton].forEach(btn => {
        btn.disabled = true;
        btn.setAttribute('aria-disabled', 'true');
      });
    };

    // Speed control handler
    speedControl.addEventListener('change', () => {
      playbackSpeed = parseFloat(speedControl.value);
      if (currentAudio) currentAudio.playbackRate = playbackSpeed;
    });

    // Load and initialize audio
    loadingDiv.style.display = 'block';
    fetch(scriptJson)
      .then(response => response.json())
      .then(scriptArray => {
        // Determine whether a Meaning column is needed based on data
        const hasMeaning = scriptArray.some(item => {
          const val = (function getMeaningProbe(it) {
            if (meaningFieldParam && it && (meaningFieldParam in it)) return it[meaningFieldParam];
            return it?.meaning ?? it?.translation ?? it?.en ?? '';
          })(item);
          return typeof val === 'string' ? val.trim().length > 0 : Boolean(val);
        });

        // Adjust thead/colgroup for dynamic columns
        const tableEl = document.getElementById(`transcript-table-${ordinal}`);
        const colgroupEl = tableEl && tableEl.querySelector('colgroup');
        const theadRowEl = tableEl && tableEl.querySelector('thead tr');
        if (!hasMeaning && colgroupEl && theadRowEl) {
          // Remove meaning column definition
          const meaningCol = colgroupEl.querySelector('.col-meaning');
          if (meaningCol) meaningCol.remove();
          // Remove meaning header cell (3rd th)
          const ths = theadRowEl.querySelectorAll('th');
          if (ths && ths[2]) ths[2].remove();
        }

        // Preload audio files
        const preloadPromises = scriptArray.map(item => new Promise((resolve, reject) => {
          const audio = new Audio(audioPath + item.audio);
          audio.preload = 'auto';
          let ready = false;
          const cleanup = () => {
            audio.removeEventListener('canplaythrough', onReady);
            audio.removeEventListener('error', onError);
          };
          const onReady = () => { ready = true; cleanup(); resolve(audio); };
          const onError = () => { cleanup(); reject(new Error(`Failed to load ${item.audio}`)); };
          audio.addEventListener('canplaythrough', onReady, { once: true });
          audio.addEventListener('error', onError, { once: true });
          // Fallback in case canplaythrough never fires
          setTimeout(() => { if (!ready) resolve(audio); }, 4000);
        }));

        Promise.all(preloadPromises)
          .then(audios => {
            preloadedAudios = audios;
            loadingDiv.style.display = 'none';
            enableControls();

            // Build transcript table
            scriptArray.forEach((item, index) => {
              const tr = document.createElement('tr');
              tr.classList.add('transcript-row');
              tr.dataset.index = index;
              tr.setAttribute('tabindex', '0');
              tr.setAttribute('role', 'button');
              const labelText = item.type === 'dialogue'
                ? `${item.speaker}: ${item.text}`
                : `Effect: ${item.name}`;
              tr.setAttribute('aria-label', `Play line ${index + 1}: ${labelText}`);

              // Speaker
              const tdSpeaker = document.createElement('td');
              tdSpeaker.textContent = item.type === 'dialogue' ? (item.speaker ?? '') : '';

              // Text
              const tdText = document.createElement('td');
              if (item.type === 'dialogue') {
                tdText.textContent = item.text ?? '';
              } else if (item.type === 'effect') {
                const i = document.createElement('i');
                i.textContent = `Effect: ${item.name}`;
                tdText.appendChild(i);
              }

              tr.appendChild(tdSpeaker);
              tr.appendChild(tdText);

              // Meaning (optional)
              if (hasMeaning) {
                const tdMeaning = document.createElement('td');
                tdMeaning.textContent = getMeaning(item) || '';
                tr.appendChild(tdMeaning);
              }

              tr.addEventListener('click', async () => {
                // If not playing, this counts as a "Play" action, so play engage sound
                if (state !== 'playing') await tryPlaySfx(sfxInsert);
                playSingleClip(index);
              });
              tr.addEventListener('keydown', async (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                  if (state !== 'playing') await tryPlaySfx(sfxInsert);
                  playSingleClip(index);
                }
              });

              tableBody.appendChild(tr);
            });

            // Playback functions
            function updateIndexLabel() {
              if (currentIndex >= 0) {
                indexLabel.textContent = `${currentIndex + 1} / ${scriptArray.length}`;
              } else {
                indexLabel.textContent = '—';
              }
            }

            function attachAudioHandlers(audio) {
              if (!audio) return;
              audio.playbackRate = playbackSpeed;
              // Duration labels
              const computeDuration = () => {
                let d = NaN;
                if (isFinite(audio.duration) && audio.duration > 0) {
                  d = audio.duration;
                } else if (audio.seekable && audio.seekable.length) {
                  d = Number(audio.seekable.end(0)) || NaN;
                }
                durationLabel.textContent = formatTime(d);
                progress.setAttribute('aria-valuetext', `0:00 of ${formatTime(d)}`);
              };
              computeDuration();
              progress.disabled = false;
              progress.value = 0;
              progress.style.setProperty('--pct', '0%');
              elapsedLabel.textContent = '0:00';
              updateIndexLabel();
              audio.ontimeupdate = () => {
                if (!isFinite(audio.duration) || audio.duration <= 0) return;
                const pct = (audio.currentTime / audio.duration) * 100;
                const clamped = clamp(pct, 0, 100);
                progress.value = clamped;
                progress.style.setProperty('--pct', `${clamped}%`);
                const elapsed = formatTime(audio.currentTime);
                elapsedLabel.textContent = elapsed;
                progress.setAttribute('aria-valuetext', `${elapsed} of ${formatTime(audio.duration)}`);
              };
              audio.onloadedmetadata = computeDuration;
            }

            function detachAudioHandlers(audio) {
              if (!audio) return;
              audio.ontimeupdate = null;
            }

            function onSequenceEnd() {
              if (state === 'playing' && currentIndex < scriptArray.length - 1) {
                timeoutId = setTimeout(() => {
                  currentIndex++;
                  playNext();
                }, pauseDuration);
              } else {
                state = 'stopped';
                setPlayVisual('play');
                removeHighlight();
                tryPlaySfx(sfxEject);
              }
            }

            function playSingleClip(index) {
              if (timeoutId) clearTimeout(timeoutId);
              if (currentAudio) { currentAudio.pause(); detachAudioHandlers(currentAudio); }
              currentIndex = Math.max(0, Math.min(index, scriptArray.length - 1));
              currentAudio = preloadedAudios[currentIndex];
              currentAudio.currentTime = 0; // Reset to start
              currentAudio.playbackRate = playbackSpeed;
              highlightRow(currentIndex);
              currentAudio.play();
              state = 'playing';
              lastSingleClip = true; // mark mode
              setPlayVisual('pause');
              statusLive.textContent = `Playing line ${currentIndex + 1} of ${scriptArray.length}`;
              attachAudioHandlers(currentAudio);
              currentAudio.onended = () => {
                // Keep highlight so user sees reference point
                state = 'stopped';
                setPlayVisual('play');
                statusLive.textContent = `Finished line ${currentIndex + 1}. Press Play to continue with the conversation.`;
              };
            }

            function playSequence() {
              if (state === 'paused') {
                if (lastSingleClip) {
                  currentAudio.onended = onSequenceEnd;
                  lastSingleClip = false;
                }
                currentAudio.play();
                state = 'playing';
                setPlayVisual('pause');
                statusLive.textContent = `Resumed line ${currentIndex + 1} of ${scriptArray.length}`;
              } else {
                if (currentAudio) { currentAudio.pause(); detachAudioHandlers(currentAudio); }
                currentIndex = currentIndex < 0 ? 0 : currentIndex;
                playNext();
              }
              state = 'playing';
            }

            function pausePlayback() {
              if (currentAudio) currentAudio.pause();
              if (timeoutId) clearTimeout(timeoutId);
              state = 'paused';
              setPlayVisual('resume');
              statusLive.textContent = 'Paused';
            }

            function playNext() {
              if (currentIndex >= scriptArray.length) {
                state = 'stopped';
                setPlayVisual('play');
                removeHighlight();
                return;
              }
              if (currentAudio) { currentAudio.pause(); detachAudioHandlers(currentAudio); }
              currentAudio = preloadedAudios[currentIndex];
              currentAudio.currentTime = 0;
              currentAudio.playbackRate = playbackSpeed;
              highlightRow(currentIndex);
              currentAudio.play();
              setPlayVisual('pause');
              statusLive.textContent = `Playing line ${currentIndex + 1} of ${scriptArray.length}`;
              attachAudioHandlers(currentAudio);
              currentAudio.onended = onSequenceEnd;
            }

            // Skip controls
            prevButton.addEventListener('click', async () => {
              await tryPlaySfx(sfxInsert); // Button click sound (using insert as generic click/engage)
              if (currentIndex > 0) {
                currentIndex--;
                if (state === 'playing') {
                  if (timeoutId) clearTimeout(timeoutId);
                  playNext();
                } else {
                  playSingleClip(currentIndex);
                }
              }
            });

            nextButton.addEventListener('click', async () => {
              await tryPlaySfx(sfxInsert); // Button click sound
              if (currentIndex < scriptArray.length - 1) {
                currentIndex++;
                if (state === 'playing') {
                  if (timeoutId) clearTimeout(timeoutId);
                  playNext();
                } else {
                  playSingleClip(currentIndex);
                }
              } else if (currentIndex < 0) {
                playSingleClip(0); // Start from first if no current index
              }
            });

            // Play/Pause toggle
            playButton.addEventListener('click', async () => {
              if (state === 'playing') {
                tryPlaySfx(sfxEject); // Disengage sound (concurrent is fine for stop)
                pausePlayback();
              } else {
                await tryPlaySfx(sfxInsert); // Engage sound (wait for click before playing)
                // If we just finished (or are stopped after) a single clip, advance to the next line for sequence playback
                if (lastSingleClip && state !== 'paused') {
                  // Only advance if not already at final line
                  if (currentIndex < scriptArray.length - 1) {
                    currentIndex = currentIndex + 1; // start sequence from the following line
                  } else {
                    // If user was on last line, restart sequence from beginning
                    currentIndex = 0;
                    statusLive.textContent = 'Restarting from the beginning.';
                  }
                  lastSingleClip = false; // reset flag
                }
                playSequence();
              }
            });

            // Progress/seek
            progress.addEventListener('input', () => {
              if (!currentAudio || !isFinite(currentAudio.duration) || currentAudio.duration <= 0) return;
              const pct = parseFloat(progress.value) / 100;
              currentAudio.currentTime = clamp(currentAudio.duration * pct, 0, currentAudio.duration - 0.01);
              elapsedLabel.textContent = formatTime(currentAudio.currentTime);
              progress.style.setProperty('--pct', `${clamp(parseFloat(progress.value), 0, 100)}%`);
            });

            // Keyboard shortcuts scoped to this player (focus or hover within container)
            container.addEventListener('focusin', () => { hasFocus = true; });
            container.addEventListener('focusout', () => {
              setTimeout(() => { hasFocus = container.contains(document.activeElement); }, 0);
            });
            container.addEventListener('mouseenter', () => { hasFocus = true; });
            container.addEventListener('mouseleave', () => { hasFocus = container.contains(document.activeElement); });
            document.addEventListener('keydown', (e) => {
              if (!hasFocus) return;
              const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
              if (tag === 'input' || tag === 'select' || tag === 'textarea' || tag === 'button') return;
              if (e.key === ' ') {
                e.preventDefault();
                if (state === 'playing') pausePlayback(); else playSequence();
              } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                prevButton.click();
              } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                nextButton.click();
              }
            });

            // Highlighting helpers
            function highlightRow(index) {
              tableBody.querySelectorAll('.transcript-row').forEach(el => {
                el.classList.remove('playing');
                el.removeAttribute('aria-current');
              });
              const row = tableBody.querySelector(`[data-index="${index}"]`);
              if (row) {
                row.classList.add('playing');
                row.setAttribute('aria-current', 'true');
                // keep row visible
                row.scrollIntoView({ block: 'nearest', inline: 'nearest' });
              }
            }

            function removeHighlight() {
              tableBody.querySelectorAll('.transcript-row').forEach(el => {
                el.classList.remove('playing');
                el.removeAttribute('aria-current');
              });
            }
          })
          .catch(error => {
            console.error('Error preloading audio:', error);
            loadingDiv.textContent = 'Failed to load audio';
            loadingDiv.setAttribute('aria-live', 'assertive');
            disableControls();
          });
      })
      .catch(error => {
        console.error('Error loading JSON:', error);
        loadingDiv.textContent = 'Failed to load script';
        disableControls();
      });
  })();
</script>

{{ partial "audio-global-script.html" . }}

<style>
  /* Container */
  .audio-player {
    padding: 10px;
  }

  /* Controls */
  .controls {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    margin-bottom: 8px;
    flex-wrap: wrap;
  }

  .left-controls,
  .right-controls {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .speed-label {
    font-size: 12px;
    opacity: 0.8;
  }

  .icon-button {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    border-radius: 8px;
    background-color: #f2f4f8;
    color: #0a2a6b;
    border: 1px solid #d5d9e2;
    padding: 8px 12px;
    cursor: pointer;
    transition: background-color 0.2s, border-color 0.2s, transform 0.02s;
    font-size: 14px;
  }

  .icon-button .icon {
    line-height: 0;
    display: inline-flex;
  }

  .icon-button.primary {
    background-color: #0a37a7;
    border-color: #0a37a7;
    color: #fff;
  }

  .icon-button:hover {
    background-color: #e8ebf1;
  }

  .icon-button.primary:hover {
    background-color: #082d8a;
  }

  .icon-button:active {
    transform: translateY(1px);
  }

  .icon-button[disabled],
  .icon-button[aria-disabled="true"] {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .icon-button .btn-label {
    user-select: none;
  }

  @media (max-width: 520px) {
    .icon-button .btn-label {
      display: none;
    }
  }

  /* Toggle play/pause icons via data-state */
  button[data-state="play"] .icon-pause {
    display: none;
  }

  button[data-state="pause"] .icon-play {
    display: none;
  }

  /* Progress row */
  .progress-row {
    display: grid;
    grid-template-columns: auto 1fr auto auto;
    gap: 8px;
    align-items: center;
    margin: 6px 0 10px;
  }

  .time {
    font-variant-numeric: tabular-nums;
    font-size: 12px;
    color: #444;
  }

  .index {
    font-size: 12px;
    color: #444;
    justify-self: end;
    min-width: 64px;
    text-align: right;
  }

  .progress {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 8px;
    border-radius: 999px;
    background: linear-gradient(90deg, #0a37a7 var(--pct, 0%), #e0e6ef var(--pct, 0%));
    outline: none;
  }

  .progress:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .progress::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    background: #0a37a7;
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: 0 0 0 1px #0a37a7;
    cursor: pointer;
  }

  .progress::-moz-range-thumb {
    width: 14px;
    height: 14px;
    background: #0a37a7;
    border-radius: 50%;
    border: 2px solid #fff;
    box-shadow: 0 0 0 1px #0a37a7;
    cursor: pointer;
  }

  /* Select (speed) */
  select {
    background-color: #0a37a7;
    color: white;
    border: none;
    border-radius: 6px;
    padding: 6px 8px;
    cursor: pointer;
    font-size: 14px;
  }

  select:hover {
    background-color: #082d8a;
  }

  select option {
    background-color: white;
    color: black;
  }

  /* SFX Toggle */
  .sfx-control {
    display: flex;
    align-items: center;
    gap: 4px;
    margin-left: 8px;
  }

  .sfx-checkbox {
    width: 16px;
    height: 16px;
    cursor: pointer;
    accent-color: #0a37a7;
  }

  .sfx-label {
    font-size: 12px;
    cursor: pointer;
    user-select: none;
    color: #444;
    font-weight: 600;
  }

  @media (prefers-color-scheme: dark) {
    .sfx-label {
      color: #c9d4f0;
    }
  }

  [data-bs-theme="dark"] .sfx-label {
    color: #c9d4f0;
  }

  /* BT Toggle */
  .bt-control {
    display: flex;
    align-items: center;
    gap: 4px;
    margin-left: 8px;
  }

  .bt-checkbox {
    width: 16px;
    height: 16px;
    cursor: pointer;
    accent-color: #0a37a7;
  }

  .bt-label {
    font-size: 12px;
    cursor: pointer;
    user-select: none;
    color: #444;
    font-weight: 600;
  }

  @media (prefers-color-scheme: dark) {
    .bt-label {
      color: #c9d4f0;
    }
  }

  [data-bs-theme="dark"] .bt-label {
    color: #c9d4f0;
  }

  /* Loading */
  .loading {
    display: none;
    font-style: italic;
    color: #666;
    margin: 10px 0;
    position: relative;
  }

  .loading::before {
    content: "";
    width: 14px;
    height: 14px;
    border: 2px solid #d0d6e0;
    border-top-color: #0a37a7;
    border-radius: 50%;
    display: inline-block;
    margin-right: 8px;
    vertical-align: -2px;
    animation: spin 0.9s linear infinite;
  }

  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  /* Screen reader only */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 1px, 1px);
    white-space: nowrap;
    border: 0;
  }

  /* Transcript table */
  .transcript-table-container {
    overflow-x: auto;
    overflow-y: auto;
    border: 3px dashed #e0e0e0;
    border-radius: 5px;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
  }

  .transcript-table {
    width: 100%;
    max-width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
  }

  .transcript-table col.col-speaker {
    width: 12ch;
  }

  .transcript-table col.col-text {
    width: auto;
  }

  .transcript-table col.col-meaning {
    width: 28ch;
  }

  .transcript-table th,
  .transcript-table td {
    border-bottom: 1px solid #eee;
    padding: 6px 8px;
    text-align: left;
    white-space: normal;
    overflow-wrap: break-word;
    word-break: normal;
    hyphens: auto;
  }

  .transcript-row {
    cursor: pointer;
  }

  .transcript-table tr.transcript-row td {
    transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out;
  }

  .audio-player .transcript-table tr.transcript-row td:first-child {
    border-left: 4px solid transparent;
  }

  .audio-player .transcript-table tr.transcript-row.playing td {
    background-color: #eaf3ff !important;
  }

  .audio-player .transcript-table tr.transcript-row.playing td:first-child {
    border-left: 4px solid #0a37a7;
  }

  .audio-player .transcript-table tr.transcript-row:focus {
    outline: 2px solid #0a37a7;
    outline-offset: -2px;
  }

  /* Mobile optimizations */
  @media (max-width: 520px) {

    /* Give browser freedom to size columns better */
    .transcript-table {
      table-layout: auto;
      min-width: 640px;
    }

    /* Tighten speaker column to free space for text */
    .transcript-table col.col-speaker {
      width: 6ch;
    }

    /* Slightly reduce cell padding on small screens */
    .transcript-table th,
    .transcript-table td {
      padding: 6px;
    }
  }

  /* Dark mode adjustments */
  @media (prefers-color-scheme: dark) {
    .audio-player .transcript-table tr.transcript-row.playing td {
      background-color: #1f2b46 !important;
      color: #f5f7ff !important;
    }

    .audio-player .transcript-table tr.transcript-row.playing td:first-child {
      border-left-color: #6ea0ff;
    }

    .audio-player .transcript-table tr.transcript-row.playing td strong,
    .audio-player .transcript-table tr.transcript-row.playing td em,
    .audio-player .transcript-table tr.transcript-row.playing td i,
    .audio-player .transcript-table tr.transcript-row.playing td a {
      color: inherit !important;
    }

    .audio-player .transcript-table tr.transcript-row.playing td a {
      text-decoration: underline;
    }

    .audio-player .transcript-table tr.transcript-row:focus {
      outline-color: #6ea0ff;
    }

    .icon-button {
      background-color: #1e293b;
      color: #dbe5ff;
      border-color: #293548;
    }

    .icon-button:hover {
      background-color: #243043;
    }

    .progress {
      background: linear-gradient(90deg, #6ea0ff var(--pct, 0%), #2b3a55 var(--pct, 0%));
    }

    .progress::-webkit-slider-thumb,
    .progress::-moz-range-thumb {
      background: #6ea0ff;
      box-shadow: 0 0 0 1px #6ea0ff;
    }

    .time,
    .index {
      color: #c9d4f0;
    }
  }

  /* Respect theme toggle via Bootstrap's data-bs-theme="dark" */
  [data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td {
    background-color: #1f2b46 !important;
    color: #f5f7ff !important;
  }

  [data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td:first-child {
    border-left-color: #6ea0ff;
  }

  [data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td strong,
  [data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td em,
  [data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td i,
  [data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td a {
    color: inherit !important;
  }

  [data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row.playing td a {
    text-decoration: underline;
  }

  [data-bs-theme="dark"] .audio-player .transcript-table tr.transcript-row:focus {
    outline-color: #6ea0ff;
  }

  [data-bs-theme="dark"] .icon-button {
    background-color: #1e293b;
    color: #dbe5ff;
    border-color: #293548;
  }

  [data-bs-theme="dark"] .icon-button:hover {
    background-color: #243043;
  }

  [data-bs-theme="dark"] .progress {
    background: linear-gradient(90deg, #6ea0ff var(--pct, 0%), #2b3a55 var(--pct, 0%));
  }

  [data-bs-theme="dark"] .progress::-webkit-slider-thumb,
  [data-bs-theme="dark"] .progress::-moz-range-thumb {
    background: #6ea0ff;
    box-shadow: 0 0 0 1px #6ea0ff;
  }

  [data-bs-theme="dark"] .time,
  [data-bs-theme="dark"] .index {
    color: #c9d4f0;
  }
</style>